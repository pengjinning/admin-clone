{"version":3,"file":"dom-utils-DQVJ0pwT.js","sources":["../../src/core/utils/dom-utils.ts"],"sourcesContent":["/**\n * DOM Utility Functions - Helpers for DOM manipulation and analysis\n */\n\nimport type { BoundingBox } from '../types/component';\n\n/**\n * Generate a unique ID\n */\nexport function generateId(): string {\n  return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);\n}\n\n/**\n * Get the bounding box of an element\n */\nexport function getBoundingBox(element: Element): BoundingBox {\n  const rect = element.getBoundingClientRect();\n  return {\n    x: rect.x + window.scrollX,\n    y: rect.y + window.scrollY,\n    width: rect.width,\n    height: rect.height,\n  };\n}\n\n/**\n * Get a unique CSS selector for an element\n */\nexport function getUniqueSelector(element: Element): string {\n  // Try ID first\n  if (element.id) {\n    return `#${element.id}`;\n  }\n  \n  // Build path from element to root\n  const path: string[] = [];\n  let current: Element | null = element;\n  \n  while (current && current !== document.body && current !== document.documentElement) {\n    let selector = current.tagName.toLowerCase();\n    \n    // Add classes\n    if (current.className && typeof current.className === 'string') {\n      const classes = current.className.trim().split(/\\s+/).filter(c => c && !c.startsWith('_'));\n      if (classes.length > 0) {\n        selector += '.' + classes.slice(0, 2).join('.');\n      }\n    }\n    \n    // Add nth-child if needed for uniqueness\n    const parent: Element | null = current.parentElement;\n    if (parent) {\n      const siblings = Array.from(parent.children).filter(\n        (child) => child.tagName === current!.tagName\n      );\n      if (siblings.length > 1) {\n        const index = siblings.indexOf(current) + 1;\n        selector += `:nth-child(${index})`;\n      }\n    }\n    \n    path.unshift(selector);\n    current = parent;\n    \n    // Limit path depth\n    if (path.length >= 5) {\n      break;\n    }\n  }\n  \n  return path.join(' > ');\n}\n\n/**\n * Alias for getUniqueSelector\n */\nexport const generateSelector = getUniqueSelector;\n\n/**\n * Get all CSS classes from an element\n */\nexport function getClassList(element: Element): string[] {\n  if (!element.className || typeof element.className !== 'string') {\n    return [];\n  }\n  return element.className.trim().split(/\\s+/).filter(c => c);\n}\n\n/**\n * Check if element has any of the specified class prefixes\n */\nexport function hasClassPrefix(element: Element, prefixes: string[]): string | null {\n  const classes = getClassList(element);\n  for (const cls of classes) {\n    for (const prefix of prefixes) {\n      if (cls.startsWith(prefix)) {\n        return cls;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Find the closest ancestor with any of the specified class prefixes\n */\nexport function findAncestorWithClassPrefix(element: Element, prefixes: string[]): Element | null {\n  let current: Element | null = element;\n  while (current) {\n    if (hasClassPrefix(current, prefixes)) {\n      return current;\n    }\n    current = current.parentElement;\n  }\n  return null;\n}\n\n/**\n * Get visible text content from an element\n */\nexport function getVisibleText(element: Element): string {\n  const text = element.textContent?.trim() || '';\n  return text.substring(0, 100); // Limit length\n}\n\n/**\n * Check if an element is visible\n */\nexport function isElementVisible(element: Element): boolean {\n  const style = window.getComputedStyle(element);\n  return (\n    style.display !== 'none' &&\n    style.visibility !== 'hidden' &&\n    style.opacity !== '0' &&\n    element.getBoundingClientRect().width > 0 &&\n    element.getBoundingClientRect().height > 0\n  );\n}\n\n/**\n * Find all elements matching a selector that are visible\n */\nexport function findVisibleElements(selector: string, root: Element | Document = document): Element[] {\n  const elements = Array.from(root.querySelectorAll(selector));\n  return elements.filter(isElementVisible);\n}\n\n/**\n * Get data attributes from an element\n */\nexport function getDataAttributes(element: Element): Record<string, string> {\n  const data: Record<string, string> = {};\n  const htmlElement = element as HTMLElement;\n  \n  if (htmlElement.dataset) {\n    for (const [key, value] of Object.entries(htmlElement.dataset)) {\n      if (value !== undefined) {\n        data[key] = value;\n      }\n    }\n  }\n  \n  return data;\n}\n\n/**\n * Get form field value\n */\nexport function getFieldValue(element: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement): string | string[] | boolean {\n  if (element instanceof HTMLInputElement) {\n    if (element.type === 'checkbox' || element.type === 'radio') {\n      return element.checked;\n    }\n    return element.value;\n  }\n  \n  if (element instanceof HTMLSelectElement) {\n    if (element.multiple) {\n      return Array.from(element.selectedOptions).map(opt => opt.value);\n    }\n    return element.value;\n  }\n  \n  return element.value;\n}\n\n/**\n * Wait for DOM to be stable (no mutations for specified time)\n */\nexport function waitForDomStable(timeout = 500): Promise<void> {\n  return new Promise((resolve) => {\n    let timer: ReturnType<typeof setTimeout>;\n    \n    const observer = new MutationObserver(() => {\n      clearTimeout(timer);\n      timer = setTimeout(() => {\n        observer.disconnect();\n        resolve();\n      }, timeout);\n    });\n    \n    observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n    });\n    \n    // Initial timer in case no mutations occur\n    timer = setTimeout(() => {\n      observer.disconnect();\n      resolve();\n    }, timeout);\n  });\n}\n\n/**\n * Find element by text content\n */\nexport function findElementByText(text: string, selector = '*'): Element | null {\n  const elements = document.querySelectorAll(selector);\n  for (const el of elements) {\n    if (el.textContent?.includes(text)) {\n      return el;\n    }\n  }\n  return null;\n}\n\n/**\n * Get element's XPath\n */\nexport function getXPath(element: Element): string {\n  const paths: string[] = [];\n  let current: Element | null = element;\n  \n  while (current && current.nodeType === Node.ELEMENT_NODE) {\n    let index = 1;\n    let sibling: Element | null = current.previousElementSibling;\n    \n    while (sibling) {\n      if (sibling.tagName === current.tagName) {\n        index++;\n      }\n      sibling = sibling.previousElementSibling;\n    }\n    \n    const tagName = current.tagName.toLowerCase();\n    const pathIndex = `[${index}]`;\n    paths.unshift(`${tagName}${pathIndex}`);\n    \n    current = current.parentElement;\n  }\n  \n  return '/' + paths.join('/');\n}\n"],"names":["generateId","getBoundingBox","element","rect","getUniqueSelector","path","current","selector","classes","c","parent","siblings","child","index","generateSelector","getClassList","getVisibleText","_a","isElementVisible","style","findVisibleElements","root"],"mappings":"AASO,SAASA,GAAqB,CACnC,OAAO,KAAK,SAAS,SAAS,EAAE,EAAE,UAAU,EAAG,EAAE,EAAI,KAAK,SAAS,SAAS,EAAE,EAAE,UAAU,EAAG,EAAE,CACjG,CAKO,SAASC,EAAeC,EAA+B,CAC5D,MAAMC,EAAOD,EAAQ,sBAAA,EACrB,MAAO,CACL,EAAGC,EAAK,EAAI,OAAO,QACnB,EAAGA,EAAK,EAAI,OAAO,QACnB,MAAOA,EAAK,MACZ,OAAQA,EAAK,MAAA,CAEjB,CAKO,SAASC,EAAkBF,EAA0B,CAE1D,GAAIA,EAAQ,GACV,MAAO,IAAIA,EAAQ,EAAE,GAIvB,MAAMG,EAAiB,CAAA,EACvB,IAAIC,EAA0BJ,EAE9B,KAAOI,GAAWA,IAAY,SAAS,MAAQA,IAAY,SAAS,iBAAiB,CACnF,IAAIC,EAAWD,EAAQ,QAAQ,YAAA,EAG/B,GAAIA,EAAQ,WAAa,OAAOA,EAAQ,WAAc,SAAU,CAC9D,MAAME,EAAUF,EAAQ,UAAU,KAAA,EAAO,MAAM,KAAK,EAAE,UAAYG,GAAK,CAACA,EAAE,WAAW,GAAG,CAAC,EACrFD,EAAQ,OAAS,IACnBD,GAAY,IAAMC,EAAQ,MAAM,EAAG,CAAC,EAAE,KAAK,GAAG,EAElD,CAGA,MAAME,EAAyBJ,EAAQ,cACvC,GAAII,EAAQ,CACV,MAAMC,EAAW,MAAM,KAAKD,EAAO,QAAQ,EAAE,OAC1CE,GAAUA,EAAM,UAAYN,EAAS,OAAA,EAExC,GAAIK,EAAS,OAAS,EAAG,CACvB,MAAME,EAAQF,EAAS,QAAQL,CAAO,EAAI,EAC1CC,GAAY,cAAcM,CAAK,GACjC,CACF,CAMA,GAJAR,EAAK,QAAQE,CAAQ,EACrBD,EAAUI,EAGNL,EAAK,QAAU,EACjB,KAEJ,CAEA,OAAOA,EAAK,KAAK,KAAK,CACxB,CAKO,MAAMS,EAAmBV,EAKzB,SAASW,EAAab,EAA4B,CACvD,MAAI,CAACA,EAAQ,WAAa,OAAOA,EAAQ,WAAc,SAC9C,CAAA,EAEFA,EAAQ,UAAU,OAAO,MAAM,KAAK,EAAE,OAAOO,GAAKA,CAAC,CAC5D,CAkCO,SAASO,EAAed,EAA0B,CAhHlD,IAAAe,EAkHL,SADaA,EAAAf,EAAQ,cAAR,YAAAe,EAAqB,SAAU,IAChC,UAAU,EAAG,GAAG,CAC9B,CAKO,SAASC,EAAiBhB,EAA2B,CAC1D,MAAMiB,EAAQ,OAAO,iBAAiBjB,CAAO,EAC7C,OACEiB,EAAM,UAAY,QAClBA,EAAM,aAAe,UACrBA,EAAM,UAAY,KAClBjB,EAAQ,wBAAwB,MAAQ,GACxCA,EAAQ,sBAAA,EAAwB,OAAS,CAE7C,CAKO,SAASkB,EAAoBb,EAAkBc,EAA2B,SAAqB,CAEpG,OADiB,MAAM,KAAKA,EAAK,iBAAiBd,CAAQ,CAAC,EAC3C,OAAOW,CAAgB,CACzC"}